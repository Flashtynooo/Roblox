local Players = game:GetService("Players")
local lp = Players.LocalPlayer
local RunService = game:GetService("RunService")
local char = lp.Character or lp.CharacterAdded:Wait()
local hum = char:WaitForChild("Humanoid")
local HRP = char:WaitForChild("HumanoidRootPart")

-- Animations
local animWalk = Instance.new("Animation")
animWalk.AnimationId = "rbxassetid://180426354"

local animAttack1 = Instance.new("Animation")
animAttack1.AnimationId = "rbxassetid://218504594"

local animAttack2 = Instance.new("Animation")
animAttack2.AnimationId = "rbxassetid://74863286"

local walkTrack, atk1Track, atk2Track
local active = false
local finished = false
local trackedTarget = nil
local noclipped = false

-- Noclip ciblé
local function setNoclipBetween(char1, char2, state)
	for _, part1 in ipairs(char1:GetDescendants()) do
		if part1:IsA("BasePart") then
			for _, part2 in ipairs(char2:GetDescendants()) do
				if part2:IsA("BasePart") then
					pcall(function()
						part1.CanCollide = not state
					end)
					pcall(function()
						part2.CanCollide = not state
					end)
				end
			end
		end
	end
end

-- Trouver le joueur le plus proche
local function getClosestPlayer(maxDist)
	local closest, shortest = nil, maxDist
	for _, plr in pairs(Players:GetPlayers()) do
		if plr ~= lp and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
			local dist = (HRP.Position - plr.Character.HumanoidRootPart.Position).Magnitude
			if dist < shortest then
				shortest = dist
				closest = plr
			end
		end
	end
	return closest, shortest
end

-- Suivi et comportement
task.spawn(function()
	while not finished do
		task.wait(0.1)

		if not trackedTarget then
			local found, dist = getClosestPlayer(10)
			if found then
				trackedTarget = found

				-- Si le joueur quitte le jeu
				found.AncestryChanged:Connect(function(_, parent)
					if not parent then
						if walkTrack then walkTrack:Stop() end
						if noclipped and trackedTarget.Character then
							setNoclipBetween(char, trackedTarget.Character, false)
						end
						finished = true
					end
				end)

				-- Jouer l’animation de marche
				active = true
				walkTrack = hum:LoadAnimation(animWalk)
				walkTrack:Play()

				-- Activer le noclip
				setNoclipBetween(char, found.Character, true)
				noclipped = true
			end
		end

		if trackedTarget and trackedTarget.Character and trackedTarget.Character:FindFirstChild("HumanoidRootPart") then
			local targetHRP = trackedTarget.Character.HumanoidRootPart
			local dist = (HRP.Position - targetHRP.Position).Magnitude

			if dist > 10 then
				-- STOP tout si trop loin
				if walkTrack and walkTrack.IsPlaying then
					walkTrack:Stop()
				end
				if noclipped and trackedTarget.Character then
					setNoclipBetween(char, trackedTarget.Character, false)
				end
				finished = true
				break
			end

			hum:MoveTo(targetHRP.Position)

			if dist <= 1 then
				if walkTrack and walkTrack.IsPlaying then walkTrack:Stop() end
				hum:Move(Vector3.zero)

				atk1Track = hum:LoadAnimation(animAttack1)
				atk2Track = hum:LoadAnimation(animAttack2)
				atk1Track:Play()
				atk2Track:Play()

				local done1, done2 = false, false

				atk1Track.Stopped:Connect(function() done1 = true end)
				atk2Track.Stopped:Connect(function() done2 = true end)

				repeat task.wait() until done1 and done2

				-- Fin du script
				if noclipped and trackedTarget.Character then
					setNoclipBetween(char, trackedTarget.Character, false)
				end
				finished = true
			end
		end
	end
end)
